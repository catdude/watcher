This is an overview of the new test plan I'm implementing in Go.

* The "TestMaster" table will contain single-line OIDs and the top
  OID for table-based items. These are the OIDs that the SNMP query
  engine will send requests for.

* The "TestItem" table will contain all single-line OIDs and the 
  line-item members of the OID tables that we want to retain in
  InfluxDB. We will use those items to match against returned
  values. All readings that aren't called out in TestItem will
  be ignored.

* The "TestParse" table will contain entries ONLY for those table-
  based objects that have more than one level of indexing. This 
  information will be used to parse table output into individual
  readings, and to build InfluxDB tags.
  Examples:
    -- ifTable will not be in this table, since it has only a single
       index (interface number).
    -- .1.3.6.1.4.1.303.3.3.12.19.4.5.1.4 (dpcDnccIQoSStInrouteBWDis)
       will have a value of 2, since it is indexed on dnccQosInrouteGroup
       and dnccQosInrouteID.
    -- .1.3.6.1.4.1.303.3.3.12.19.502.1.5 (dnccQosRemThru) will have a 
       value of 3, since it is indexed on dnccQosRemInrouteGroup,
       dnccQosRemInroute, and dnccQosRemSnum.


DETAILS
-----------------
Given a class of device to test (i.e. 1 for DNCCs), figure out which  
measurements need to be performed:
    SELECT mID FROM measurement WHERE class=1
and read values into a slice (measSlice).

Using the slice of measurments, determine what OIDs need to be bulkwalked 
to retrieve all needed readings. For each row in measSlice:
    SELECT oid FROM test_master WHERE measurement = <mID>
and read values into a slice (oidSlice).

For each row in oidSlice,
    SELECT name FROM ois_name WHERE oid=<oid>
and add to a map of oid->name (nameMap)

Determine the IP addresses and community strings of all devices needing 
to be read:
    SELECT ip FROM hosts WHERE class=<class ID>
and add to a slice (hostSlice).

For each item in hostSlice, send an asynchronous bulkwalk request for 
all items in oidSlice (combine OIDs where possible).
    TBD

For each host, when callback indicates that all requested OIDs have been
received, figure out levels of indexing for all indexed OIDs:
    SELECT oid, levels FROM test_parse WHERE measurement = <mID>
and store in a slice (depthSlice).

Create index slices for each level identified in depthSlice (ndx0Slice to ndxNSlice).

For each item in depthSlice, search through return values until
    strings.HasPrefix(ndxSlice, retVal)
Continue reading until HasPrefix is false. For each line until HasPrefix
is false, split on periods. For each <ndxNSlice>, test whether ndxNSlice contains
the index value. 

Special case: for .1.3.6.1.4.1.303.3.3.12.19.3.501.1.28, build map of 
sequential group num from retval -> Hughes group number, update group numbers
to match.

Prepare to insert into InfluxDB:
    series=<test_item.series>, host=<ip>, site=<siteID>, name=<oid_name.name>,
    index=<index octets separated by hyphens>, value=<value from return line>
Insert into InfluxDB

